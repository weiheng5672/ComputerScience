# 心得

抽象資料型態與自定義資料型態
差別在於前者包括了操作資料的方法
這是物件的雛型，抽象資料型態並不具備繼承等物件導向特性，僅僅是封裝了資料以及操作資料的方法
前面提到了，操作資料的方法可以讓人抽離細節，專注在問題，所以叫做抽象
將這個抽象直接和資料本身封裝在一起，這就是所謂的，抽象資料型態

# Deepseek

**抽象資料型別（Abstract Data Type, ADT）**的概念，與**自定義資料型別（User-defined Data Type）**進行比較。

### 1. 自定義資料型別（User-defined Data Type）
自定義資料型別是程式設計中常見的一種方式，允許程式設計師根據需求定義新的資料結構。例如：
- 在 C 語言中，可以使用 `struct` 來定義一個新的資料型別。
- 在 Pascal 中，可以使用 `record` 來定義。

這些自定義型別主要用於組織和儲存資料，但它們**僅定義了資料的儲存結構**，並**不包含對這些資料的操作**。例如，你可以定義一個結構來表示一個堆疊（stack），但這個結構本身並不會自動提供「推入（push）」或「彈出（pop）」等操作。

### 2. 抽象資料型別（Abstract Data Type, ADT）
抽象資料型別則更進一步，它不僅定義了資料的儲存結構，還**定義了對這些資料的操作**。ADT 將資料和操作封裝在一起，並提供一個介面供外部使用，同時隱藏內部的實現細節。

#### ADT 的兩個重要特性：
1. **封裝（Encapsulation）**：將資料和操作封裝在一起，形成一個獨立的單元。
2. **資料隱藏（Data Hiding）**：隱藏內部的資料結構，外部程式只能透過提供的操作來存取資料，這提高了程式的可靠性和安全性。

#### 例子：堆疊（Stack）的 ADT
假設我們要實現一個堆疊的 ADT，我們可以定義以下操作：
- `push(item)`：將一個項目推入堆疊。
- `pop()`：從堆疊中彈出一個項目。
- `isEmpty()`：檢查堆疊是否為空。
- `isFull()`：檢查堆疊是否已滿。

在 Java 中，可以使用 `interface` 來定義這個 ADT：
```java
interface StackType {
    public int pop();       // 彈出堆疊頂部的項目
    public void push(int item); // 將項目推入堆疊
    public boolean isEmpty();  // 檢查堆疊是否為空
    public boolean isFull();   // 檢查堆疊是否已滿
}
```
這個 `interface` 定義了堆疊的行為，但並未指定具體的實現細節（例如堆疊是用陣列還是鏈結串列來實現）。這些細節可以在其他地方實現。

### 3. 自定義型別與 ADT 的關聯
- **自定義型別**僅定義了資料的儲存結構，例如 C 的 `struct` 或 Pascal 的 `record`。
- **ADT** 則在自定義型別的基礎上，進一步定義了對這些資料的操作，並將資料和操作封裝在一起。

### 4. 物件導向語言中的 ADT
在現代物件導向語言（如 Java、C++、Python 等）中，ADT 的概念被進一步擴展為**類別（Class）**。類別不僅可以定義資料結構和操作，還可以支援繼承、多型等特性，使得程式設計更加靈活和強大。

### 總結
- **自定義型別**：僅定義資料的儲存結構。
- **抽象資料型別（ADT）**：定義資料結構及其操作，並封裝這些細節，提供一個清晰的介面供外部使用。
- **物件導向語言中的類別**：是 ADT 的擴展，支援更多特性如繼承和多型。

ADT 的出現是程式語言設計的一大進步，它使得程式設計師能夠更好地組織和管理程式碼，並提高程式的可靠性和可維護性。