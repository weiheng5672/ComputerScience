# 前言

- 以下以二元樹為例，演示所謂的抽象地操作資料結構，忽略底層的實現細節
- 其實說再多，這東西就只是往後運用資料結構時的普遍方式
- 一般情況即使需要了解底層原理，也不需要去理解底層的實現細節

# 介紹

- 這個案例研習，涉及了樹的操作，是存儲名單的一個情境，為了簡化，以字母代表名單。
- 也就是說，這個案例的出發點是一個鏈表，字母的鏈表。
- 但是，鏈表這種結構，只能夠實踐順序搜尋，如果要使用更快的搜尋算法，必須重新組織資料結構。

到這裏我就有個小細節想了解，就是通常做這件事的時候，是會複製整份信息，形成新的資料結構，還是說會去修改原始數據的資料結構？

另外新節點始終可以不需要切開樹，但是這樣會不會造成，隨著新節點加入，整體上來看，有更適合作為根節點的中间元素？

# Deepseek

這個案例研習確實涉及了樹的操作，特別是二叉搜索樹（Binary Search Tree, BST）的使用，來實現高效的搜索、插入和打印操作。以下針對你的問題進行詳細解答：

### 1. **資料結構的轉換：複製還是修改原始數據？**
在實際應用中，是否複製整份信息或修改原始數據的資料結構，取決於具體的需求和場景。以下是兩種常見的做法：

- **複製整份信息**：
  - 這種做法通常用於需要保留原始數據的情況。例如，原始數據是一個鏈表，但為了提高搜索效率，我們可以將鏈表中的數據複製到一個新的二叉搜索樹中。這樣，原始鏈表保持不變，而新的二叉搜索樹用於高效的搜索和插入操作。
  - 這種方法的優點是原始數據不會被破壞，適合需要保留歷史數據或並行操作的場景。缺點是會占用更多的內存空間，因為需要存儲兩份數據。

- **修改原始數據的資料結構**：
  - 這種做法通常用於不需要保留原始數據結構的情況。例如，如果原始數據是一個鏈表，我們可以直接將其轉換為二叉搜索樹，並在轉換過程中釋放鏈表的內存。
  - 這種方法的優點是節省內存空間，因為不需要存儲兩份數據。缺點是原始數據結構被破壞，無法恢復。

在實際應用中，選擇哪種方式取決於具體需求。如果原始數據結構需要保留，則選擇複製；如果不需要保留，則可以選擇修改原始數據結構。

### 2. **新節點插入與樹的平衡性**
在二叉搜索樹中，新節點始終可以作為葉子節點插入，而不需要切開樹。這種插入方式確實簡單且高效，但隨著新節點的加入，樹的結構可能會變得不平衡，從而影響搜索效率。

- **不平衡的情況**：
  - 如果插入的節點始終比當前節點大或小，樹可能會退化成一個鏈表，導致搜索效率從 O(log n) 降低到 O(n)。
  - 例如，如果依次插入 A, B, C, D, E，樹可能會變成一個向右傾斜的鏈表，導致搜索效率降低。

- **平衡二叉搜索樹**：
  - 為了解決這個問題，可以使用平衡二叉搜索樹（如 AVL 樹或紅黑樹）。這些樹結構在插入和刪除節點時會自動調整樹的結構，保持樹的平衡，從而確保搜索效率始終為 O(log n)。
  - 在平衡二叉搜索樹中，插入新節點時，樹會自動旋轉和調整，使得樹的高度保持平衡，從而避免退化成鏈表的情況。

- **根節點的選擇**：
  - 在普通的二叉搜索樹中，根節點通常是初始數據的中間元素。隨著新節點的插入，根節點可能不再是最佳的中間元素。但在平衡二叉搜索樹中，樹的自平衡機制會自動調整根節點的位置，使得樹保持平衡。
  - 如果你使用的是普通的二叉搜索樹，並且發現樹變得非常不平衡，可以考慮重新構建樹，選擇新的中間元素作為根節點。

### 總結：
- **資料結構的轉換**：根據需求選擇複製或修改原始數據結構。如果需要保留原始數據，則複製；如果不需要，則可以直接修改原始數據結構。
- **樹的平衡性**：隨著新節點的插入，普通的二叉搜索樹可能會變得不平衡，影響搜索效率。可以使用平衡二叉搜索樹（如 AVL 樹或紅黑樹）來保持樹的平衡，確保高效的搜索操作。

# GPT

### **8.4 一個簡短的案例研究**  

讓我們考慮一個存儲按字母順序排列的姓名列表的任務。我們假設對這個列表執行的操作如下：  

- **搜尋**某個條目是否存在  
- **按字母順序列印**整個列表  
- **插入**一個新條目  

我們的目標是開發一個存儲系統，並提供一組函數來執行這些操作，從而構建出一個完整的抽象工具。  

我們先來考慮存儲這個列表的選擇。如果我們按照**鏈結串列（linked list）**的方式存儲列表，那麼搜尋操作就必須採用**順序搜尋（sequential search）**。正如我們在**第 5 章**所討論的，當列表變得很長時，這種方法可能會變得非常低效。因此，我們希望找到一種方法，使得我們可以使用**二分搜尋演算法（binary search algorithm，參見 5.5 節）**來進行搜尋。  

要使用二分搜尋，我們的存儲系統必須允許我們找到列表中某個區段的**中間條目**。因此，我們決定將這個列表存儲為**二元樹（binary tree）**，具體方法如下：  

1. **選擇列表的中間條目作為根節點（root node）。**  
2. **將剩餘的前半部分的中間條目作為根的左子節點（left child），將後半部分的中間條目作為根的右子節點（right child）。**  
3. **繼續這樣劃分，每次取區段的中間條目作為父節點的子節點，直到整個列表建構完成。**  

舉例來說，圖 8.20 所示的樹代表了字母列表 **A, B, C, D, E, F, G, H, I, J, K, L, M**。（當區段內的元素數量為偶數時，我們選擇較大的那個作為中間條目。）  

### **搜尋操作**  

要在這樣的樹中搜尋某個條目時，我們將目標值與根節點進行比較：  

- **如果相等，搜尋成功。**  
- **如果不相等，則根據目標值的大小，選擇移動到左子節點（較小）或右子節點（較大），然後繼續搜尋。**  
- **重複此過程，直到找到目標值（搜尋成功）或遇到空指標（None，表示搜尋失敗）。**  

圖 8.21 展示了如何用**鏈結樹結構（linked tree structure）**來實作這個搜尋過程。在 Python 中，`elif` 關鍵字是 `else: if ...` 的簡寫。請注意，這個函數只是對 **圖 5.14** 中原始二分搜尋函數的調整，本質上並沒有太大變化。唯一的區別是，我們現在將演算法表述為**在越來越小的子樹中搜尋**，而不是**在越來越小的列表區段中搜尋**（圖 8.22）。  

### **按字母順序列印列表**  

儘管我們將列表存儲為**二元樹**，但我們仍然可以輕鬆地按照字母順序列印它。方法如下：  

1. **先遞迴列印左子樹**（左子樹的所有元素都比根節點小）。  
2. **列印根節點**。  
3. **遞迴列印右子樹**（右子樹的所有元素都比根節點大）。  

這樣做可以確保列表按照正確的字母順序輸出。這種方法的本質是**遞迴（recursion）**，因為列印一棵樹的過程可以拆分為列印更小的子樹。根據這一思路，我們可以寫出完整的 Python 函數來列印樹（圖 8.24）。在函數 `PrintTree` 中，我們遞迴調用 `PrintTree` 來處理左子樹和右子樹。  

這個函數的遞迴終止條件是當我們遇到一棵**空樹（None）**時，此時函數直接返回，不會進一步遞迴。這個終止條件**保證了遞迴最終會停止**，因為每次遞迴呼叫時，樹的大小都變小了。  

### **插入新條目**  

你可能會直覺地認為，插入新條目可能需要「切開」樹來騰出空間，但實際上，新的節點**總是可以作為葉節點（leaf node）來附加**，無論它的值是多少。  

插入的過程其實和搜尋過程相似：  

1. **從根節點開始，沿著搜尋路徑向下移動**，就像在搜尋這個值一樣。  
2. **當搜尋過程到達一個空指標（None）時，這裡就是新節點應該插入的位置。**  
3. **將新的節點附加到這個空位，作為新的葉節點。**  

如果我們在搜尋過程中發現這個值已經存在於樹中，則不執行插入（避免重複值）。  

圖 8.26 展示了這個過程的 Python 程式碼，其中 `TreeNode()` 是用來創建新節點的函數（這部分的定義在後續章節會提到）。  

### **結論**  

我們發現，透過**鏈結二元樹（linked binary tree structure）**，再搭配**搜尋、列印和插入**函數，我們構建了一個完整的抽象工具（abstract tool）。  

當這個工具被適當實作時，使用者就可以完全**忽略底層的存儲細節**，僅僅透過提供操作函數來管理一個「按字母順序排列的列表」。但實際上，這些名單條目並不是以傳統的陣列方式存儲，而是**分散在記憶體中的鏈結二元樹節點**。